{
  "id": "heat-boiler-simulation",
  "label": "Heat Boiler Simulation",
  "nodes": [
    {
      "id": "hb-inject-30s",
      "type": "inject",
      "z": "heat-boiler-simulation",
      "name": "30s Interval",
      "props": [
        {
          "p": "payload"
        }
      ],
      "repeat": "30",
      "crontab": "",
      "once": false,
      "onceDelay": 0.1,
      "topic": "",
      "payload": "",
      "payloadType": "date",
      "x": 120,
      "y": 80,
      "wires": [["hb-simulation-function"]]
    },
    {
      "id": "hb-simulation-function",
      "type": "function",
      "z": "heat-boiler-simulation",
      "name": "Heat Boiler Data Generator",
      "func": "// Heat Boiler Data Simulation\n// Realistic mathematical model for thermal systems\n\nconst now = new Date();\nconst hour = now.getHours();\nconst dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));\n\n// Temperature model (°C)\nfunction calculateTemperature() {\n    // Seasonal variation (higher demand in winter)\n    const seasonalFactor = 0.3 + 0.7 * Math.cos(2 * Math.PI * (dayOfYear - 172) / 365);\n    \n    // Daily variation (higher demand in morning/evening)\n    const morningPeak = Math.exp(-Math.pow((hour - 7) / 2, 2));\n    const eveningPeak = Math.exp(-Math.pow((hour - 19) / 2, 2));\n    const dailyFactor = Math.max(morningPeak, eveningPeak);\n    \n    const baseTemp = 80; // Operating temperature\n    const demandFactor = seasonalFactor * (0.5 + 0.5 * dailyFactor);\n    const noise = (Math.random() - 0.5) * 5; // ±2.5°C noise\n    \n    return baseTemp + demandFactor * 20 + noise;\n}\n\n// Pressure model (bar)\nfunction calculatePressure() {\n    const temp = calculateTemperature();\n    const basePressure = 2.0; // Base pressure\n    const tempEffect = (temp - 80) * 0.02; // Pressure change with temperature\n    const noise = (Math.random() - 0.5) * 0.2; // ±0.1 bar noise\n    \n    return Math.max(1.0, Math.min(4.0, basePressure + tempEffect + noise));\n}\n\n// Efficiency model (%)\nfunction calculateEfficiency() {\n    const temp = calculateTemperature();\n    const pressure = calculatePressure();\n    \n    // Temperature effect on efficiency\n    const tempEfficiency = Math.exp(-Math.pow((temp - 85) / 20, 2));\n    \n    // Pressure effect on efficiency\n    const pressureEfficiency = Math.exp(-Math.pow((pressure - 2.5) / 1.0, 2));\n    \n    const baseEfficiency = 85; // %\n    const combinedEfficiency = tempEfficiency * pressureEfficiency;\n    const noise = (Math.random() - 0.5) * 3; // ±1.5% noise\n    \n    return Math.max(70, Math.min(95, baseEfficiency * combinedEfficiency + noise));\n}\n\n// Power output model (kW)\nfunction calculatePowerOutput() {\n    const temp = calculateTemperature();\n    const efficiency = calculateEfficiency();\n    \n    // Heat demand calculation\n    const baseDemand = 100; // kW\n    const tempDemand = (temp - 60) * 2; // Higher temp = higher demand\n    \n    // Efficiency factor\n    const efficiencyFactor = efficiency / 100;\n    \n    const powerOutput = (baseDemand + tempDemand) / efficiencyFactor;\n    \n    return Math.max(0, powerOutput);\n}\n\n// Generate data with fault scenarios\nfunction generateHeatBoilerData() {\n    const faultProbability = 0.002; // 0.2% chance of fault\n    const isFault = Math.random() < faultProbability;\n    \n    let temperature = calculateTemperature();\n    let pressure = calculatePressure();\n    let efficiency = calculateEfficiency();\n    let powerOutput = calculatePowerOutput();\n    \n    // Fault scenarios\n    if (isFault) {\n        const faultType = Math.floor(Math.random() * 3);\n        switch (faultType) {\n            case 0: // High temperature fault\n                temperature += 30;\n                pressure += 1.0;\n                efficiency *= 0.8;\n                powerOutput *= 0.9;\n                break;\n            case 1: // Low pressure fault\n                pressure *= 0.5;\n                efficiency *= 0.6;\n                powerOutput *= 0.5;\n                break;\n            case 2: // Efficiency fault\n                efficiency *= 0.5;\n                powerOutput *= 0.7;\n                break;\n        }\n    }\n    \n    return {\n        device_id: `hb_${String(Math.floor(Math.random() * 4) + 1).padStart(3, '0')}`,\n        device_type: 'heat_boiler',\n        timestamp: now.toISOString(),\n        data: {\n            temperature: Math.round(temperature * 100) / 100,\n            pressure: Math.round(pressure * 100) / 100,\n            efficiency: Math.round(efficiency * 100) / 100,\n            power_output: Math.round(powerOutput * 100) / 100\n        },\n        status: isFault ? 'fault' : 'operational',\n        location: 'site_d',\n        fault_type: isFault ? ['high_temperature', 'low_pressure', 'efficiency'][faultType] : null\n    };\n}\n\n// Generate and return data\nconst hbData = generateHeatBoilerData();\nmsg.payload = hbData;\nmsg.topic = `devices/heat_boiler/${hbData.device_id}/telemetry`;\n\nreturn msg;",
      "outputs": 1,
      "noerr": 0,
      "initialize": "",
      "finalize": "",
      "libs": [],
      "x": 320,
      "y": 80,
      "wires": [["hb-mqtt-output", "hb-validation"]]
    },
    {
      "id": "hb-mqtt-output",
      "type": "mqtt out",
      "z": "heat-boiler-simulation",
      "name": "MQTT Output",
      "topic": "",
      "qos": "1",
      "retain": false,
      "respTopic": "",
      "contentType": "",
      "userProps": "",
      "correl": "",
      "expiry": "",
      "broker": "mqtt-broker",
      "x": 520,
      "y": 80,
      "wires": []
    },
    {
      "id": "hb-validation",
      "type": "function",
      "z": "heat-boiler-simulation",
      "name": "Data Validation",
      "func": "// Validate heat boiler data\nconst data = msg.payload;\nconst errors = [];\n\n// Check required fields\nif (!data.device_id || !data.timestamp || !data.data) {\n    errors.push('Missing required fields');\n}\n\n// Validate data ranges\nconst ranges = {\n    temperature: { min: 50, max: 150 },\n    pressure: { min: 0.5, max: 5.0 },\n    efficiency: { min: 60, max: 98 },\n    power_output: { min: 0, max: 500 }\n};\n\nfor (const [key, range] of Object.entries(ranges)) {\n    const value = data.data[key];\n    if (value < range.min || value > range.max) {\n        errors.push(`${key} out of range: ${value} (${range.min}-${range.max})`);\n    }\n}\n\n// Check for physical consistency\nif (data.data.efficiency < 70 && data.data.power_output > 0) {\n    errors.push('Low efficiency with power output');\n}\n\nif (data.data.pressure < 1.0 && data.data.temperature > 80) {\n    errors.push('Low pressure with high temperature');\n}\n\nif (errors.length > 0) {\n    msg.error = errors;\n    msg.status = 'invalid';\n} else {\n    msg.status = 'valid';\n}\n\nreturn msg;",
      "outputs": 1,
      "noerr": 0,
      "initialize": "",
      "finalize": "",
      "libs": [],
      "x": 320,
      "y": 160,
      "wires": [["hb-error-handling"]]
    },
    {
      "id": "hb-error-handling",
      "type": "switch",
      "z": "heat-boiler-simulation",
      "name": "Error Check",
      "property": "status",
      "propertyType": "msg",
      "rules": [
        {
          "t": "eq",
          "v": "valid",
          "vt": "str"
        },
        {
          "t": "eq",
          "v": "invalid",
          "vt": "str"
        }
      ],
      "check": "all",
      "repair": false,
      "outputs": 2,
      "x": 520,
      "y": 160,
      "wires": [["hb-influxdb"], ["hb-error-log"]]
    },
    {
      "id": "hb-influxdb",
      "type": "influxdb out",
      "z": "heat-boiler-simulation",
      "influxdb": "influxdb-config",
      "name": "Store Data",
      "measurement": "heat_boiler_data",
      "precision": "ms",
      "retentionPolicy": "",
      "database": "",
      "precisionV18FluxV20": "ms",
      "retentionPolicyV18Flux": "",
      "org": "renewable_energy",
      "bucket": "iot_data",
      "x": 720,
      "y": 120,
      "wires": []
    },
    {
      "id": "hb-error-log",
      "type": "debug",
      "z": "heat-boiler-simulation",
      "name": "Error Log",
      "active": true,
      "tosidebar": true,
      "console": false,
      "tostatus": false,
      "complete": "payload",
      "targetType": "msg",
      "statusVal": "",
      "statusType": "auto",
      "x": 720,
      "y": 160,
      "wires": []
    }
  ],
  "version": "3.1.0",
  "configs": [
    {
      "id": "mqtt-broker",
      "type": "mqtt-broker",
      "name": "MQTT Broker",
      "broker": "mosquitto",
      "port": "1883",
      "clientid": "node-red-simulation",
      "autoConnect": true,
      "usetls": false,
      "protocolVersion": "4",
      "keepalive": "60",
      "cleansession": true,
      "birthTopic": "",
      "birthQos": "0",
      "birthPayload": "",
      "birthMsg": {},
      "closeTopic": "",
      "closeQos": "0",
      "closePayload": "",
      "closeMsg": {},
      "willTopic": "",
      "willQos": "0",
      "willPayload": "",
      "willMsg": {},
      "userProps": "",
      "sessionExpiry": ""
    },
    {
      "id": "influxdb-config",
      "type": "influxdb",
      "hostname": "influxdb",
      "port": "8086",
      "protocol": "http",
      "database": "iot_data",
      "name": "InfluxDB",
      "usetls": false,
      "tls": "",
      "influxdbVersion": "2.0",
      "url": "http://influxdb:8086",
      "rejectUnauthorized": false,
      "token": "your-influxdb-token",
      "organization": "renewable_energy",
      "bucket": "iot_data"
    }
  ]
} 