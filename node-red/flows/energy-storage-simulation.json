[
  {
    "id": "es-inject-30s",
    "type": "inject",
    "z": "energy-storage-simulation",
    "name": "30s Interval",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 120,
    "y": 80,
    "wires": [
      [
        "es-simulation-function"
      ]
    ]
  },
  {
    "id": "es-simulation-function",
    "type": "function",
    "z": "energy-storage-simulation",
    "name": "Energy Storage Data Generator",
    "func": "// Energy Storage System Data Simulation\n// Realistic mathematical model for battery systems\n\nconst now = new Date();\nconst hour = now.getHours();\nconst dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));\n\n// State of Charge model (%)\nfunction calculateStateOfCharge() {\n    // Daily cycle (charge during day, discharge during night)\n    const solarHours = 6 + 6 * Math.sin(2 * Math.PI * (dayOfYear - 172) / 365); // Seasonal variation\n    const isDaytime = hour >= 6 && hour <= 18;\n    \n    let soc = context.get('soc') || 50; // Initialize or get previous SOC\n    \n    if (isDaytime) {\n        // Charging during day\n        const chargeRate = 2; // % per 30 seconds\n        soc = Math.min(95, soc + chargeRate);\n    } else {\n        // Discharging during night\n        const dischargeRate = 1.5; // % per 30 seconds\n        soc = Math.max(5, soc - dischargeRate);\n    }\n    \n    // Add realistic variations\n    const noise = (Math.random() - 0.5) * 1; // ±0.5% noise\n    soc += noise;\n    \n    // Store for next iteration\n    context.set('soc', soc);\n    \n    return Math.max(0, Math.min(100, soc));\n}\n\n// Voltage model (V)\nfunction calculateVoltage() {\n    const soc = calculateStateOfCharge();\n    const baseVoltage = 400; // Nominal voltage\n    const socEffect = (soc - 50) * 0.5; // Voltage variation with SOC\n    const noise = (Math.random() - 0.5) * 5; // ±2.5V noise\n    \n    return Math.max(350, Math.min(450, baseVoltage + socEffect + noise));\n}\n\n// Current model (A)\nfunction calculateCurrent() {\n    const soc = calculateStateOfCharge();\n    const isDaytime = hour >= 6 && hour <= 18;\n    \n    let current;\n    if (isDaytime) {\n        // Charging current\n        current = 50 + (95 - soc) * 2; // Higher current when SOC is low\n    } else {\n        // Discharging current\n        current = -(30 + soc * 0.5); // Higher current when SOC is high\n    }\n    \n    const noise = (Math.random() - 0.5) * 10; // ±5A noise\n    return current + noise;\n}\n\n// Temperature model (°C)\nfunction calculateTemperature() {\n    const current = Math.abs(calculateCurrent());\n    const baseTemp = 25; // Ambient temperature\n    const currentHeat = current * 0.1; // Heat generation from current\n    const seasonalVariation = 10 * Math.sin(2 * Math.PI * (dayOfYear - 172) / 365);\n    const noise = (Math.random() - 0.5) * 3; // ±1.5°C noise\n    \n    return baseTemp + currentHeat + seasonalVariation + noise;\n}\n\n// Cycle count model\nfunction calculateCycleCount() {\n    let cycleCount = context.get('cycleCount') || 0;\n    const soc = calculateStateOfCharge();\n    \n    // Increment cycle count on full charge/discharge cycles\n    if (soc > 90 && context.get('lastHighSOC') !== true) {\n        context.set('lastHighSOC', true);\n    } else if (soc < 10 && context.get('lastHighSOC') === true) {\n        cycleCount += 0.5; // Half cycle for full discharge\n        context.set('lastHighSOC', false);\n    }\n    \n    context.set('cycleCount', cycleCount);\n    return cycleCount;\n}\n\n// Power output model (kW)\nfunction calculatePowerOutput() {\n    const voltage = calculateVoltage();\n    const current = calculateCurrent();\n    const efficiency = 0.95; // 95% efficiency\n    \n    return (voltage * current * efficiency) / 1000; // Convert to kW\n}\n\n// Generate data with fault scenarios\nfunction generateEnergyStorageData() {\n    const faultProbability = 0.001; // 0.1% chance of fault\n    const isFault = Math.random() < faultProbability;\n    \n    let stateOfCharge = calculateStateOfCharge();\n    let voltage = calculateVoltage();\n    let current = calculateCurrent();\n    let temperature = calculateTemperature();\n    let cycleCount = calculateCycleCount();\n    let powerOutput = calculatePowerOutput();\n    \n    // Fault scenarios\n    if (isFault) {\n        const faultType = Math.floor(Math.random() * 4);\n        switch (faultType) {\n            case 0: // High temperature fault\n                temperature += 25;\n                voltage *= 0.9;\n                powerOutput *= 0.8;\n                break;\n            case 1: // Low voltage fault\n                voltage *= 0.7;\n                current *= 0.5;\n                powerOutput *= 0.35;\n                break;\n            case 2: // Overcharge fault\n                stateOfCharge = 98;\n                voltage += 20;\n                temperature += 10;\n                break;\n            case 3: // Deep discharge fault\n                stateOfCharge = 2;\n                voltage *= 0.8;\n                powerOutput *= 0.3;\n                break;\n        }\n    }\n    \n    return {\n        device_id: `es_${String(Math.floor(Math.random() * 6) + 1).padStart(3, '0')}`,\n        device_type: 'energy_storage',\n        timestamp: now.toISOString(),\n        data: {\n            state_of_charge: Math.round(stateOfCharge * 100) / 100,\n            voltage: Math.round(voltage * 100) / 100,\n            current: Math.round(current * 100) / 100,\n            temperature: Math.round(temperature * 100) / 100,\n            cycle_count: Math.round(cycleCount * 100) / 100,\n            power_output: Math.round(powerOutput * 100) / 100\n        },\n        status: isFault ? 'fault' : 'operational',\n        location: 'site_e',\n        fault_type: isFault ? ['high_temperature', 'low_voltage', 'overcharge', 'deep_discharge'][faultType] : null\n    };\n}\n\n// Generate and return data\nconst esData = generateEnergyStorageData();\nmsg.payload = esData;\nmsg.topic = `devices/energy_storage/${esData.device_id}/telemetry`;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 80,
    "wires": [
      [
        "es-mqtt-output",
        "es-validation"
      ]
    ]
  },
  {
    "id": "es-mqtt-output",
    "type": "mqtt out",
    "z": "energy-storage-simulation",
    "name": "MQTT Output",
    "topic": "",
    "qos": "1",
    "retain": false,
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt-broker-config",
    "x": 520,
    "y": 80,
    "wires": []
  },
  {
    "id": "es-validation",
    "type": "function",
    "z": "energy-storage-simulation",
    "name": "Data Validation",
    "func": "// Validate energy storage data\nconst data = msg.payload;\nconst errors = [];\n\n// Check required fields\nif (!data.device_id || !data.timestamp || !data.data) {\n    errors.push('Missing required fields');\n}\n\n// Validate data ranges\nconst ranges = {\n    state_of_charge: { min: 0, max: 100 },\n    voltage: { min: 300, max: 500 },\n    current: { min: -100, max: 100 },\n    temperature: { min: -10, max: 60 },\n    cycle_count: { min: 0, max: 10000 },\n    power_output: { min: -50, max: 50 }\n};\n\nfor (const [key, range] of Object.entries(ranges)) {\n    const value = data.data[key];\n    if (value < range.min || value > range.max) {\n        errors.push(`${key} out of range: ${value} (${range.min}-${range.max})`);\n    }\n}\n\n// Check for physical consistency\nconst expectedPower = (data.data.voltage * data.data.current * 0.95) / 1000;\nif (Math.abs(data.data.power_output - expectedPower) > Math.abs(expectedPower) * 0.2) {\n    errors.push('Power output inconsistent with voltage and current');\n}\n\nif (data.data.state_of_charge > 95 && data.data.current > 0) {\n    errors.push('Charging with high state of charge');\n}\n\nif (data.data.state_of_charge < 5 && data.data.current < 0) {\n    errors.push('Discharging with low state of charge');\n}\n\nif (errors.length > 0) {\n    msg.error = errors;\n    msg.status = 'invalid';\n} else {\n    msg.status = 'valid';\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 160,
    "wires": [
      [
        "es-error-handling"
      ]
    ]
  },
  {
    "id": "es-error-handling",
    "type": "switch",
    "z": "energy-storage-simulation",
    "name": "Error Check",
    "property": "status",
    "propertyType": "msg",
    "rules": [
      {
        "t": "eq",
        "v": "valid",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "invalid",
        "vt": "str"
      }
    ],
    "check": "all",
    "repair": false,
    "outputs": 2,
    "x": 520,
    "y": 160,
    "wires": [
      [
        "es-influxdb"
      ],
      [
        "es-error-log"
      ]
    ]
  },
  {
    "id": "es-influxdb",
    "type": "influxdb out",
    "z": "energy-storage-simulation",
    "influxdb": "influxdb-config",
    "name": "Store Data",
    "measurement": "energy_storage_data",
    "precision": "ms",
    "retentionPolicy": "",
    "database": "",
    "precisionV18FluxV20": "ms",
    "retentionPolicyV18Flux": "",
    "org": "renewable_energy",
    "bucket": "renewable_energy",
    "x": 720,
    "y": 120,
    "wires": []
  },
  {
    "id": "es-error-log",
    "type": "debug",
    "z": "energy-storage-simulation",
    "name": "Error Log",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 720,
    "y": 160,
    "wires": []
  },
  {
    "id": "mqtt-broker-config",
    "type": "mqtt-broker",
    "name": "MQTT Broker",
    "broker": "mosquitto",
    "port": "1883",
    "clientid": "node-red-simulation",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "birthMsg": {},
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "closeMsg": {},
    "willTopic": "",
    "willQos": "0",
    "willPayload": "",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  },
  {
    "id": "influxdb-config",
    "type": "influxdb",
    "hostname": "influxdb",
    "port": "8086",
    "protocol": "http",
    "database": "renewable_energy",
    "name": "InfluxDB",
    "usetls": false,
    "tls": "",
    "influxdbVersion": "2.0",
    "url": "http://influxdb:8086",
    "rejectUnauthorized": false,
    "token": "",
    "organization": "renewable_energy",
    "bucket": "renewable_energy"
  }
]