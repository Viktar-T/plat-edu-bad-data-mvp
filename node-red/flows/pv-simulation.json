[
  {
    "id": "pv-inject-30s",
    "type": "inject",
    "z": "pv-simulation",
    "name": "30s Interval",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 120,
    "y": 80,
    "wires": [
      [
        "pv-simulation-function"
      ]
    ]
  },
  {
    "id": "pv-simulation-function",
    "type": "function",
    "z": "pv-simulation",
    "name": "PV Data Generator",
    "func": "// Photovoltaic Panel Data Simulation\n// Enhanced realistic mathematical model with seasonal and daily variations\n\nconst now = new Date();\nconst hour = now.getHours();\nconst dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));\nconst latitude = 45.0; // Example latitude\n\n// Solar irradiance model (W/m²)\nfunction calculateIrradiance() {\n    // Seasonal variation (peak in summer)\n    const seasonalFactor = 0.5 + 0.5 * Math.cos(2 * Math.PI * (dayOfYear - 172) / 365);\n    \n    // Daily variation (peak at solar noon)\n    const solarNoon = 12; // Approximate solar noon\n    const dailyFactor = Math.max(0, Math.cos(Math.PI * (hour - solarNoon) / 12));\n    \n    // Cloud cover effect (random)\n    const cloudCover = Math.random() < 0.3 ? (0.3 + Math.random() * 0.4) : 1.0;\n    \n    // Base irradiance with realistic fluctuations\n    const baseIrradiance = 1000; // Standard test conditions\n    const noise = (Math.random() - 0.5) * 50; // ±25 W/m² noise\n    \n    return Math.max(0, baseIrradiance * seasonalFactor * dailyFactor * cloudCover + noise);\n}\n\n// Temperature model (°C)\nfunction calculateTemperature() {\n    const baseTemp = 25; // Standard test conditions\n    const irradiance = calculateIrradiance();\n    const tempRise = irradiance * 0.03; // Temperature rise due to irradiance\n    const ambientTemp = 20 + 10 * Math.sin(2 * Math.PI * (hour - 6) / 24); // Daily ambient cycle\n    const seasonalTemp = 5 * Math.sin(2 * Math.PI * (dayOfYear - 172) / 365); // Seasonal variation\n    const noise = (Math.random() - 0.5) * 5; // ±2.5°C noise\n    \n    return baseTemp + tempRise + ambientTemp + seasonalTemp + noise;\n}\n\n// Voltage model (V)\nfunction calculateVoltage() {\n    const baseVoltage = 48; // Nominal voltage\n    const temp = calculateTemperature();\n    const tempCoeff = -0.003; // Temperature coefficient (%/°C)\n    const voltageVariation = baseVoltage * tempCoeff * (temp - 25) / 100;\n    const irradiance = calculateIrradiance();\n    const irradianceEffect = (irradiance / 1000 - 1) * 0.05; // ±5% variation based on irradiance\n    const noise = (Math.random() - 0.5) * 2; // ±1V noise\n    \n    return Math.max(0, baseVoltage + voltageVariation + baseVoltage * irradianceEffect + noise);\n}\n\n// Current model (A)\nfunction calculateCurrent() {\n    const irradiance = calculateIrradiance();\n    const baseCurrent = 12; // Nominal current\n    const currentVariation = baseCurrent * (irradiance / 1000);\n    const temp = calculateTemperature();\n    const tempEffect = (temp - 25) * 0.002; // Temperature effect on current\n    const noise = (Math.random() - 0.5) * 0.5; // ±0.25A noise\n    \n    return Math.max(0, currentVariation * (1 + tempEffect) + noise);\n}\n\n// Efficiency model (%)\nfunction calculateEfficiency() {\n    const temp = calculateTemperature();\n    const irradiance = calculateIrradiance();\n    \n    // Base efficiency (typical for modern panels)\n    const baseEfficiency = 20.0; // 20% efficiency\n    \n    // Temperature effect (efficiency decreases with temperature)\n    const tempEffect = -0.004 * (temp - 25); // -0.4% per °C above 25°C\n    \n    // Irradiance effect (efficiency varies with irradiance)\n    const irradianceEffect = (irradiance / 1000 - 1) * 0.02; // ±2% variation\n    \n    // Aging effect (gradual degradation over time)\n    const daysSinceInstallation = 365 * 2; // Assume 2 years old\n    const agingEffect = -0.5 * (daysSinceInstallation / 365); // -0.5% per year\n    \n    // Dirt effect (random)\n    const dirtEffect = Math.random() < 0.1 ? -Math.random() * 0.05 : 0; // 10% chance of dirt\n    \n    const noise = (Math.random() - 0.5) * 0.5; // ±0.25% noise\n    \n    return Math.max(0, Math.min(100, baseEfficiency + tempEffect + irradianceEffect + agingEffect + dirtEffect + noise));\n}\n\n// Power output model (W)\nfunction calculatePowerOutput() {\n    const voltage = calculateVoltage();\n    const current = calculateCurrent();\n    const efficiency = calculateEfficiency();\n    \n    // Theoretical power\n    const theoreticalPower = voltage * current;\n    \n    // Apply efficiency\n    return Math.max(0, theoreticalPower * (efficiency / 100));\n}\n\n// Generate data with enhanced fault scenarios\nfunction generatePVData() {\n    const faultProbability = 0.002; // 0.2% chance of fault\n    const isFault = Math.random() < faultProbability;\n    \n    let irradiance = calculateIrradiance();\n    let temperature = calculateTemperature();\n    let voltage = calculateVoltage();\n    let current = calculateCurrent();\n    let efficiency = calculateEfficiency();\n    let powerOutput = calculatePowerOutput();\n    \n    // Enhanced fault scenarios\n    if (isFault) {\n        const faultType = Math.floor(Math.random() * 5);\n        switch (faultType) {\n            case 0: // Shading fault\n                irradiance *= 0.3;\n                current *= 0.3;\n                efficiency *= 0.8;\n                powerOutput *= 0.3;\n                break;\n            case 1: // Temperature fault (hot spot)\n                temperature += 30;\n                voltage *= 0.8;\n                efficiency *= 0.7;\n                powerOutput *= 0.7;\n                break;\n            case 2: // Connection fault (loose connection)\n                voltage *= 0.5;\n                current *= 0.5;\n                efficiency *= 0.6;\n                powerOutput *= 0.25;\n                break;\n            case 3: // Microcrack fault\n                efficiency *= 0.5;\n                voltage *= 0.9;\n                powerOutput *= 0.5;\n                break;\n            case 4: // Inverter fault\n                efficiency *= 0.3;\n                powerOutput *= 0.3;\n                break;\n        }\n    }\n    \n    return {\n        device_id: `pv_${String(Math.floor(Math.random() * 10) + 1).padStart(3, '0')}`,\n        device_type: 'photovoltaic',\n        timestamp: now.toISOString(),\n        data: {\n            irradiance: Math.round(irradiance * 100) / 100,\n            temperature: Math.round(temperature * 100) / 100,\n            voltage: Math.round(voltage * 100) / 100,\n            current: Math.round(current * 100) / 100,\n            power_output: Math.round(powerOutput * 100) / 100,\n            efficiency: Math.round(efficiency * 100) / 100\n        },\n        status: isFault ? 'fault' : 'operational',\n        location: 'site_a',\n        fault_type: isFault ? ['shading', 'temperature', 'connection', 'microcrack', 'inverter'][faultType] : null\n    };\n}\n\n// Generate and return data\nconst pvData = generatePVData();\nmsg.payload = pvData;\nmsg.topic = `devices/photovoltaic/${pvData.device_id}/telemetry`;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 80,
    "wires": [
      [
        "pv-mqtt-output",
        "pv-validation"
      ]
    ]
  },
  {
    "id": "pv-mqtt-output",
    "type": "mqtt out",
    "z": "pv-simulation",
    "name": "MQTT Output",
    "topic": "",
    "qos": "1",
    "retain": false,
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt-broker-config",
    "x": 520,
    "y": 80,
    "wires": []
  },
  {
    "id": "pv-validation",
    "type": "function",
    "z": "pv-simulation",
    "name": "Data Validation",
    "func": "// Validate photovoltaic data\nconst data = msg.payload;\nconst errors = [];\n\n// Check required fields\nif (!data.device_id || !data.timestamp || !data.data) {\n    errors.push('Missing required fields');\n}\n\n// Validate data ranges\nconst ranges = {\n    irradiance: { min: 0, max: 1200 },\n    temperature: { min: -40, max: 100 },\n    voltage: { min: 0, max: 100 },\n    current: { min: 0, max: 20 },\n    power_output: { min: 0, max: 1000 },\n    efficiency: { min: 0, max: 100 }\n};\n\nfor (const [key, range] of Object.entries(ranges)) {\n    const value = data.data[key];\n    if (value < range.min || value > range.max) {\n        errors.push(`${key} out of range: ${value} (${range.min}-${range.max})`);\n    }\n}\n\n// Check for physical consistency\nconst theoreticalPower = data.data.voltage * data.data.current;\nconst actualPower = data.data.power_output;\nconst calculatedEfficiency = (actualPower / theoreticalPower) * 100;\n\nif (Math.abs(calculatedEfficiency - data.data.efficiency) > 5) {\n    errors.push(`Efficiency mismatch: calculated ${calculatedEfficiency.toFixed(2)}%, reported ${data.data.efficiency}%`);\n}\n\nif (data.data.power_output > theoreticalPower * 1.1) {\n    errors.push('Power output exceeds voltage * current');\n}\n\nif (data.data.irradiance > 0 && data.data.power_output === 0) {\n    errors.push('No power output despite irradiance');\n}\n\nif (errors.length > 0) {\n    msg.error = errors;\n    msg.status = 'invalid';\n} else {\n    msg.status = 'valid';\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 160,
    "wires": [
      [
        "pv-error-handling"
      ]
    ]
  },
  {
    "id": "pv-error-handling",
    "type": "switch",
    "z": "pv-simulation",
    "name": "Error Check",
    "property": "status",
    "propertyType": "msg",
    "rules": [
      {
        "t": "eq",
        "v": "valid",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "invalid",
        "vt": "str"
      }
    ],
    "check": "all",
    "repair": false,
    "outputs": 2,
    "x": 520,
    "y": 160,
    "wires": [
      [
        "pv-influxdb"
      ],
      [
        "pv-error-log"
      ]
    ]
  },
  {
    "id": "pv-influxdb",
    "type": "influxdb out",
    "z": "pv-simulation",
    "influxdb": "influxdb-config",
    "name": "Store Data",
    "measurement": "photovoltaic_data",
    "precision": "ms",
    "retentionPolicy": "",
    "database": "",
    "precisionV18FluxV20": "ms",
    "retentionPolicyV18Flux": "",
    "org": "renewable_energy",
    "bucket": "renewable_energy",
    "x": 720,
    "y": 120,
    "wires": []
  },
  {
    "id": "pv-error-log",
    "type": "debug",
    "z": "pv-simulation",
    "name": "Error Log",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 720,
    "y": 160,
    "wires": []
  },
  {
    "id": "mqtt-broker-config",
    "type": "mqtt-broker",
    "name": "MQTT Broker",
    "broker": "mosquitto",
    "port": "1883",
    "clientid": "node-red-pv-simulation",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "",
    "birthQos": "0",
    "birthPayload": "",
    "birthMsg": {},
    "closeTopic": "",
    "closeQos": "0",
    "closePayload": "",
    "closeMsg": {},
    "willTopic": "",
    "willQos": "0",
    "willPayload": "",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  },
  {
    "id": "influxdb-config",
    "type": "influxdb",
    "hostname": "influxdb",
    "port": "8086",
    "protocol": "http",
    "database": "renewable_energy",
    "name": "InfluxDB",
    "usetls": false,
    "tls": "",
    "influxdbVersion": "2.0",
    "url": "http://influxdb:8086",
    "rejectUnauthorized": false,
    "token": "",
    "organization": "renewable_energy",
    "bucket": "renewable_energy"
  }
] 